\chapter{Проектирование алгоритмов дискретного и быстрого теоретико-числовых преобразований для быстрого решения задач расчета свертки в целых числах и длинного умножения}
В данной главе рассмотрено представление алгоритма теоретико-числового преобразования и зафиксированы его отличительные особенности.

Были обоснованы критерии выбора модуля и примитивного корня алгоритма.
По установленным критериям с помощью программного обеспечения были подобраны эти величины.

Были указаны особенности использования 512-разрядных расширений 256-разрядных инструкций Advanced Vector Extensions (AVX-512) SIMD для архитектуры набора инструкций x86.

Была описана процедура формирования спектров входных сигналов.
\section{Описание алгоритма теоретико-числового преобразования}
В данной работе используется приближенная форма преобразования Фурье –-- теоретико-числовое преобразование \cite{NTT-Lattice}.

Теоретико-числовые преобразования (ТЧП) были разработаны в начале семидесятых годов на основе теории чисел.
Они представляют собой дискретные преобразования Фурье, определенные над конечными полями и кольцами --- поскольку эти преобразования выполняются по арифметическому модулю --- по модулю простого числа, они проявляют много интересных свойств, которые полезны для цифровой обработки сигналов.
ТЧП вычисляются в целочисленной области, и, следовательно, они считаются превосходящими по сравнению с уже существующими БПФ.

Традиционные теоретико-числовые преобразования, которые, избегая арифметики с плавающей точкой, обеспечивают точные целочисленные свертки, могут быть заданы взвешенными встречными частями \cite{FFT-convolutions}.
Пусть целые числа, $x$ и $y$, выражены в сбалансированных представлениях типа \eqref{eq: number_polynomial}
\begin{equation}\label{eq: number_polynomial}
x = \sum_{j=0}^{N-1} x_j W^j,
\end{equation}
где $0 \leq x_j < W$.

Тогда циклические и негациклические свертки удовлетворяют неравенству \eqref{eq: convolution_upper_bound}
\begin{equation}\label{eq: convolution_upper_bound}
\big\vert(x *^a y)_n\big\vert \leq \frac{N W^2}{4},
\end{equation}
где операция "$*^a$" осуществляет взвешенную свёртку для каждого $n\in\mathbb{Z}_N$ \cite{FFT-convolutions}.

Рассматривается теоретико-числовые взвешенные преобразования, основанные на арифметике над конечным коммутативным ассоциативным кольцом с единицей.
Практическим частным случаем является:
\begin{equation}\label{eq: ntt}
X_k = \sum_{j=0}^{N-1} x_j A^j g^{-j k} \in R,
\end{equation}
\begin{whereblock}
	$A$ --- обратимый в поле $R$ весовой коэффициент, который можно принять равным 1 для циклического случая, и равным $-1$ --- для негациклического (значение $A=-1$ является примитивным корнем степени $2 N$ из единицы в $R$);\\
	$g$ --- примитивный корень степени $N$ из единицы в $R$.
\end{whereblock}

Для циклического случая можно принять $A=1$, для негациклического случая --- $A=-1$ --- примитивный корень из единицы степени $2 N$ в $R$.

В негациклическом случае достаточно использовать $g = A^2$.
Когда используется конечное поле $R=GF(p)$ для простого числа $p$, вследствие \eqref{eq: convolution_upper_bound} достаточно, чтобы выполнялось неравенство
\begin{equation}\label{eq: schonhage_strassen field limit}
\frac{N W^2}{4} < \frac{p}{2}.
\end{equation}
Затем взвешенные преобразования типа \eqref{eq: ntt} со всей арифметикой, выполненной по модулю $p$, могут быть использованы для однозначного определения (возможно, биполярных) элементов преобразования \cite{loop-ntt}.
Могут быть получены границы, более четкие, чем \eqref{eq: schonhage_strassen field limit}, особенно если учитывать заполнение старших цифр нулями или специальные симметрии.
Популярным выбором является выбор чисел Ферма $p = F_m = 2^{2^m} + 1$.
Результирующее преобразование числа Ферма (FNT) обладает привлекательными свойствами \cite{ArithmeticsForFNT}, но имеет один существенный недостаток.
Преимущества FNT заключаются в способности выполнять \eqref{eq: ntt} (с генерированием скаляра $A$, равного степени 2) только на основе операций сдвига и сложения, в то время как недостаток заключается в том, что максимально допустимые длины выполнения FNT довольно ограничены.

Пример FNT может быть представлен следующим образом.
Изначально $W = 2^{16}$, и $N = 64$‚ так что циклическая или негациклическая свертка желательна для произведения $x$ и $y$ из $\mathbb{Z}_{W^N}$.
Каждый из множителей имеет размер не более 1024 бит.
Поскольку $N W^2  = 2^{38}$‚ достаточно по \eqref{eq: schonhage_strassen field limit} выбрать $p=F_6=2^64+1$.
Выбирается $A = 2$, который является 64-м корнем из $-1 \pmod{F_6}$, и $g = 4$.
Тогда взвешенное преобразование
\begin{equation}\label{eq: ntt example}
X_k = \sum_{j=0}^{63} x_j 2^j 4^{-jk} \pmod{F_6}
\end{equation}
может использоваться для вычисления негациклических сверток, соответствующих исходным целым числам $x$ и $y$, имеющим размер не более 1024 бит каждый.
Очевидно, что \eqref{eq: ntt example} или его еще более простой циклический аналог могут быть выполнены с помощью операций сдвига, сложения и операций с модулем Ферма без какого-либо явного требуемого умножения.
Из-за ограничений на длину при кодировании поворотов FNT становится сложно выполнять точное умножение целых чисел, содержащих, сотни тысяч битов \cite{ArithmeticWithNTT, NT-in-DSP}.
Эту проблему помогают решить различные многомерные подходы или преобразование Галуа \cite{FFT-over-FF}, для которого выражения, такие как \eqref{eq: ntt}, должны быть вычислены в $GF(p^2)$, где $p = 2^q - 1$ --- простое число Мерсенна.
Эти преобразования используют два факта.

Во-первых, для арифметики в $GF(p^2)$ предполагается, что каждый элемент поля равен $a + bi$, при этом все действительные и мнимые компоненты подвергаются редукции по модулю $p$ на каждом этапе.
Во-вторых, порядок мультипликативной группы равен $p^2-1=(p+1)(p-1)$, который делится на $2^{q + 1}$, что позволяет на практике использовать достаточный период, равный степени двух.

Пусть $h$ --- примитивный мультипликативный $2^{q + 1}$-й корень из 1 в $GF(p^2)$.
Для $r \leq q$
\begin{equation}\label{eq: simplifying ntt 1}
N = 2^r,\quad A=h^{(p-1) 2^{q-r-1}}, \quad g=A^2.
\end{equation}

Поскольку $A^N = -1$, в соответствии с ограничением \eqref{eq: schonhage_strassen field limit} может выполняться циклическая свертка длиной $N$ (где $A$ просто исключено из \eqref{eq: ntt}) или свертка с отрицательными цифрами.
Если $r$ строго меньше $q$, то выбираются
\begin{equation}\label{eq: simplifying ntt 2}
N = 2^r,\quad A=h^{(p-1) 2^{q-r-2}}, \quad g=A^4.
\end{equation}

По теореме Крейцбурга и Таше можно получить выражения замкнутой формы для примитивных корней в $GF(p^2)$.
Например,
$$
h = 2^{2 q - 2} + (-3)^{2 q - 2}i
$$
всегда является примитивным мультипликативным $2^{q + 1}$-ым корнем из 1.
Из \eqref{eq: simplifying ntt 1} следует, что можно использовать периоды от двух до $2^q$ для циклической или негациклической свертки.

Дальнейшим наблюдением является то, что $g \cdot g^*=1 \bmod{p}$, так что вышеупомянутые методы преобразования реального сигнала и реального результата могут быть применены, к взвешенным случаям \eqref{eq: ntt} с учетом соответствующих симметрий $X$.

Полезный пример приложений преобразования Галуа возникает, когда $p$ является простым числом Мерсенна $2^{61} - 1$.
Для фиксированной базы $W = 2^{16}$ можно, в силу \eqref{eq: schonhage_strassen field limit}, рассмотреть периоды до размера $M = 2^{27}$ цифр.
Программы для взвешенной свертки могут быть реализованы, начиная с одного примитивного корня, такого как
$$
h = 2137483648+1033321771269002680 i.
$$

Затем используются соотношения \eqref{eq: simplifying ntt 1} или \eqref{eq: simplifying ntt 2} для обработки определенных длин $2^r$.
Например, для умножения двух целых чисел, каждое из которых имеет не более 1 миллиона бит.
Можно продолжить с прямоугольными свертками следующим образом.
В соответствии с \eqref{eq: simplifying ntt 2}, делается выбор:
\begin{gather*}
N = 2^{16}, \\
A = h^{(p-1)\cdot 2^{43}} = 1973234539278172120+1244201103777839971 i, \\
g = A^4 = 1510466207055935382+120042544849731353i,
\end{gather*}
для которого можно проверить, что $A^N = i$, следовательно, $g^N = 1$ в $GF(p^2)$.
Тогда \eqref{eq: ntt} и взвешенную формулу свертки можно использовать для вычисления $n$-го разряда произведения как $\Re\big((x *^a y)_n\big)$ для $n < N$, и $\Im\big((x *^a y)_{n-N}\big)$ для $n \geq N$.
Хотя в этом примере требуются сложные БПФ с умножением с высокой 64-х битной точностью‚ \eqref{eq: schonhage_strassen field limit} гарантирует, что умножение является точным, без ошибок, связанных с вычислениями с плавающей точкой.
\section{Отличие теоретико-числового преобразования от более стандартных БПФ-алгоритмов}
ТЧП сигнала выполняется в целочисленной области, тогда как DFT/FFT – в комплексной области.
Коэффициенты NTT не имеют никакого физического смысла, поскольку операции выполняются по арифметическому модулю.
Из-за модульной арифметики все выходные данные являются целыми числами в конечном кольце, заданным модулем, и никаких приближений не происходит.
Следовательно, ТЧП не имеют ошибок округления, как в стандартных алгоритмах.
В частном случае, когда реализуется представление длинных данных в виде скаляров $x_i$ в \eqref{eq: number_polynomial}, умножение на степени W осуществляется операциями посимвольного сдвига, то есть битового сдвига в двоичном представлении $X$ в \eqref{eq: number_polynomial}.
В этом случае в ТЧП, все умножения могут быть преобразованы в сдвиги и сложения.
Это намного проще, чем сложные умножения произвольных действительных, и тем более комплексных чисел \cite{fast-multiplication-long-ints}; следовательно, FNT быстрее, чем FFT.

Если две последовательности $x(n)$ и $h(n)$ имеют битовые представления $b_1$ и $b_2$, а длина преобразования равна $N$, то вывод свертки $y(n)$ имеет максимальное $b_1+b_2+\log_2 ⁡N$ битовое представление.
В БПФ каждая выборка данных имеет действительную и мнимую части, для этого требуется два слова, одно для действительного и одно для мнимого.
Следовательно, требования к хранилищу и оборудованию как для NTT, так и для FFT остаются практически одинаковыми.

В методе FNT умножение на степень 2 реализуется как операции сдвига и сложения битов, которые намного проще по сравнению со сложными умножениями, требуемыми в методе DFT \cite{RingLWE-multiplication}.
Это обеспечивает значительную экономию времени вычислений и, следовательно, алгоритмы NTT работают быстрее, чем FFT.

\section{Программная реализация}
Согласно заданию, вышеописанный алгоритм необходимо представить в векторной форме.
Возможность векторной реализации вычислений представлена во многих современных процессорах, в данной работе для проектирования реализации, использующей AVX-512, использован эмулятор Intel\textregistered{} Software Development Emulator (Intel SDR), а для экспериментальных измерений, результаты которых представлены в главе \ref{chapter: experiments}, --– микропроцессор Intel Core i9-10980XE, реализующий архитектуру CascadeLake AVX-512 –-- это 512-разрядные расширения 256-разрядных инструкций Advanced Vector Extensions SIMD для архитектуры набора инструкций x86 (ISA), предложенных Intel в июле 2013 года и реализованных в процессорах Intel Xeon Phi x200 и Skylake-X; это включает Core-X серии (исключая Core i5-7640X и Core i7-7740X), а также новое семейство масштабируемых процессоров Xeon и встроенную серию Xeon D-2100.

Сначала выполняется подбор модуля используемого кольца.
В стандартном алгоритме Шёнхаге-Штрассена используется $m=2^{64}+1$.
Однако, в данной работе такой модуль не подходит, так как нет векторных регистров, использующих скаляры из $\mathbb{Z}_{2^{128}}$. Значение $m=2^{64}-1$ так же не подходит, так как в кольце $\mathbb{Z}_{2^{64}-1}$ нет принципиального корня 16-й степени из единицы.
Также не подходит значение $m = 2^{64}$, так как в $\mathbb{Z}_{2^{64}}$ не существует мультипликативной инверсии 16, умножение на которую требуется при обратном теоретико-числовом преобразовании, поскольку $\gcd⁡(16, 2^{64}) \ne 1$.

Таким образом, был выполнен перебор возможных $m$, начиная с $2^{64}-1$, и осуществлён произвольный выбор тех из них, которые одновременно удовлетворяют следующим критериям:
\begin{enumerate}
\item $\gcd(m, 16) = 1$,
\item $\lambda(m) \bmod{16} = 0$, где $\lambda(m)$ --- это функция Кармайкла,
\item $\exists a\bigg[a \in \mathbb{Z}_m \land a^{\lambda(m)} = 1 \land \gcd\Big(a^\frac{\lambda(m)}{16} - 1, m\Big) = 1\bigg]$.
\end{enumerate}

Расчёт функции Кармайкла выполняется следующим образом:
$$
\lambda(m)=
\begin{cases}
&\varphi(m), \text{ если } m \in \big\{p^n \mid p \in \mathcal{P} \land n \in \mathbb{N} \land (p \ge 3 \lor n < 2)\big\}, \\
&\frac{\varphi(m)}{2}, \text{ если } m \in \{2^n \mid n \in \mathbb{N} \land n \ge 3\}, \\
&\operatorname{lcm}_{i=1}^q\big(\lambda(p_i^{k_i})\big), \text{ если } m \in \begin{aligned}[t]\Big\{\prod_{i=1}^q p_i^{k_i} \mid &p_i\in\mathcal{P} \land k_i\in\mathbb{N} \land q \geq 2\\
&\land i \ne j \implies p_i \ne p_j\Big\},\end{aligned}
\end{cases}
$$
\begin{whereblock}
$\varphi(m)$ --- тотиента Эйлера,\\
$\mathcal{P}$ --- множество всех простых чисел.
\end{whereblock}

В третьем случае значение функции рассчитывается рекуррентно как наименьшее общее кратное (lcm --– least common multiplier) значений функции Кармайкла всех простых множителей ($p_i$ в соответствующей степени $k_i$) в разложении числа $m$, $q$ –-- число уникальных простых множителей в разложении $m$.
Для размеров $m$, рассматриваемых в рамках настоящей работы, разложение числа $m$ на простые достаточно выполнить путем проверки делимости на малые простые, доступные, например, в \cite{IrregularPrimes, crandallprimes}.

Значение функции Кармайкла --– минимальное целое такое, что
$$
\forall a\big[a \in \mathbb{Z}_m \implies a^{\lambda(m)} = 1 \bmod{m}\big].
$$

Тотиента Эйлера вычисляется по формуле
$$
\varphi(m) = \prod_{i=1}^q p_i^{k_i - 1} (p_i - 1).
$$

Далее, найдя $m$, значение примитивного корня 16-й степени принимается равным тому значению $g=a^\frac{\lambda(m)}{16}$ в третьем критерии, для которого справедливо
$$
\forall n\big[n\in\mathbb{N} \land n < 16 \implies g^n \ne 1 \bmod{m}\big].
$$

В настоящей работе  использованы следующие найденные значения $m$ и $g$:
\begin{align*}
m &= \textrm{0xffffffffffffffa1}, \\
g &= \textrm{0xe97df2aaae3ae452},
\end{align*}
где "0x" означает представление в шестнадцатеричной системе счисления.

Далее, выполняется ввод двух входящих потоков данных.
Входные данные умещаются в один "период", под которым понимается набор из 16 элементов данных, формируются целочисленные (определенные над кольцом $\mathbb{Z}_m$) спектры этих сигналов.
Далее по спектрам восстанавливается информация и сравнивается с вошедшим потоком данных. В случае совпадения выполняется умножение спектров.

