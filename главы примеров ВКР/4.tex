\chapter{Экспериментальное измерение эффективности векторного теоретико-числового, сверточного преобразований над кольцами, а также длинного умножения целых}\label{chapter: experiments}
В настоящей главе представлено экспериментальное обоснование и исследование оперативности выполненных в работе реализаций, определены интервалы размеров операндов, на которых алгоритмы демонстрируют лучшую производительность.

\section{Результаты проектирования теоретико-числового алгоритма Фурье}
В данной главе выполнена оценка эффективности метода теоретико-числового преобразования, предложенного в предыдущих главах.
Выполнена оценка превосходства векторного представления подобных алгоритмов над скалярным представлением.
Сделан вывод о перспективности использования векторных процессоров для решения задач умножения длинных целых.

В качестве входных данных использовались 16 целочисленных сигналов значениями:
\begin{gather}
x_{1\dots8} = \textrm{0x3fffffff}, \\
x_{9\dots18} = 0.
\end{gather}

Над данными значениями было выполнено преобразование Фурье, путём умножения их векторного представления на матрицу поворота, представленную в главе \ref{chapter: implementation}.
Упрощенный вид умножения можно схематично представить следующим образом:
$$
\begin{bmatrix}
W_{11} &  \dots & W_{1n} \\
\vdots & \ddots & \vdots \\
W_{n1} &  \dots & W_{nn}
\end{bmatrix}
\cdot
\begin{bmatrix}
t_1    \\
\vdots \\
t_n
\end{bmatrix}
=
\begin{bmatrix}
W_{11} \\
\vdots \\
W_{n1}
\end{bmatrix}
\cdot t_1 +
\begin{bmatrix}
W_{12} \\
\vdots \\
W_{n2}
\end{bmatrix}
\cdot t_2 + \dots \medspace.
$$

Каждое умножение выполнялось параллельно, что положительно сказывается на производительности \cite{PerformanceOfParallelFFT}.
В результате преобразования, значения в каждой позиции принимают вид, показанный в таблице \ref{tab: ntt results}.
\begin{table}[ht]
\caption{Результат преобразования Фурье в каждой позиции, занятой одним из входных сигналов векторного регистра m512i AVX-512}
\label{tab: ntt results}
\begin{tabular}{|l|l|l|}
\hline
\thead{Входные данные} & \thead{Спектр, полученный в\\результате ДПФ} & \thead{Восстановленные данные} \\
\hline
0x3fffffff & 0x1fffffff8 & 0x3fffffff \\
\hline
0x3fffffff & 0xba83ab6a79ba5945 & 0x3fffffff \\
\hline
0x3fffffff & 0 & 0x3fffffff \\
\hline
0x3fffffff & 0xa82bf7fe09e54a63 & 0x3fffffff \\
\hline
0x3fffffff & 0 & 0x3fffffff \\
\hline
0x3fffffff & 0x5a2959e00e5d6434 & 0x3fffffff \\
\hline
0x3fffffff & 0 & 0x3fffffff \\
\hline
0x3fffffff & 0xc417091fefa260e6 & 0x3fffffff \\
\hline
0 & 0 & 0 \\
\hline
0 & 0x3be8f6e0905d9eb9 & 0 \\
\hline
0 & 0 & 0 \\
\hline
0 & 0xa5d6a62071a29b6b & 0 \\
\hline
0 & 0 & 0 \\
\hline
0 & 0x57d40802761ab53c & 0 \\
\hline
0 & 0 & 0 \\
\hline
0 & 0x457c54960645a65a & 0 \\
\hline
\end{tabular}
\end{table}

Правильное восстановление входных данных позволяет судить об отсутствии ошибок в программном представлении алгоритма.
Далее выполнялось поточечное умножение спектра в каждой позиции.
Результаты умножения занесены в таблицу \ref{tab: ntt convolution results}.
\begin{table}[ht]
\caption{Результаты поточечного умножения длинных целых в кольце $\mathbb{Z}_{2^{64}-94}$ при выполнении свёрточного теоретико-числового преобразования}
\label{tab: ntt convolution results}
\begin{tabular}{|l|l|l|}
\hline
\thead{Спектр} & \thead{Поточеченое умножение} & \thead{Результат умножения до\\рекомбинации} \\
\hline
0x1fffffff8 & 0xffffffe00000015d & 0x0fffffff80000001 \\
\hline
0xba83ab6a79ba5945 & 0x0989803773cdd6cf & 0x1fffffff00000002 \\
\hline
0 & 0 & 0x2ffffffe80000003 \\
\hline
0xa82bf7fe09e54a63 & 0x055bba032a57eb07 & 0x3ffffffe00000004 \\
\hline
0 & 0 & 0x4ffffffd80000005 \\
\hline
0x5a2959e00e5d6434 & 0x853a75f37a03c810 & 0x5ffffffd00000006 \\
\hline
0 & 0 & 0x6ffffffc80000007 \\
\hline
0xc417091fefa260e6 & 0xaacff7e8d120d1ca & 0x7ffffffc00000008 \\
\hline
0 & 0 & 0x6ffffffc80000007 \\
\hline
0x3be8f6e0905d9eb9 & 0x0b89bb37cb1df402 & 0x5ffffffd00000006 \\
\hline
0 & 0 & 0x4ffffffd80000005 \\
\hline
0xa5d6a62071a29b6b & 0x1f82791c3e20ff82 & 0x3ffffffe00000004 \\
\hline
0 & 0 & 0x2ffffffe80000003 \\
\hline
0x57d40802761ab53c & 0xdc264f57e99c0e13 & 0x1fffffff00000002 \\
\hline
0 & 0 & 0x0fffffff80000001 \\
\hline
0x457c54960645a65a & 0xb9ddd45523daa04f & 0 \\
\hline
\end{tabular}
\end{table}

После окончания работы над реализацией перечисленных в предыдущем разделе алгоритмов было выполнено испытание производительности сложения.

Так как испытания выполнялись на процессоре, не поддерживающем AVX-512, для проверки векторизованного алгоритма сложения потребовался эмулятор Intel Software Development Emulator.
Это не позволило провести "чистый" эксперимент и выполнить измерение времени работы, поэтому результаты только доказали корректность алгоритма.

Далее были выполнены испытания умножения. Все эксперименты были выполнены десять раз, полученные значения затем были усреднены.

В первом эксперименте над умножением было выполнено сравнение умножения в столбик и умножения Карацубы с различными значениями предела длины операндов.
Чтобы уменьшить влияние кэша процессора на результаты, перед измерениями времени работы алгоритмы были запущены несколько раз с входными данными, длина которых была равна выбранному пределу.
Эксперимент показал, что лучшим значением границы для алгоритма Карацубы является 21-но машинное слово.

Далее было выполнено сравнение умножения Карацубы и алгоритма Тоом-3
При достаточном уровне разбиения алгоритм Тоом-3 вызывает умножение Карацубы.
В данном эксперименте был использован лучший вариант алгоритма Карацубы из предыдущего эксперимента.
При исследовании результатов было выяснено, что алгоритм Тоом-3 становится быстрее умножения Карацубы при длине входных операндов от 275-ти машинных слов.

\section{Оценка эффективности параллельных алгоритмов ДПФ}

В качестве результатов эксперимента были получены значения времени выполнения последовательных $T_N$ и параллельных $T_p$ алгоритмов ДПФ в зависимости от объема данных. Была выполнена экспериментальная проверка различия эффективности параллельного алгоритма ДПФ и алгоритма ДПФ с ложным разделением.

